{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This small Python library provides a convenient way to  broadcast signals to multiple listeners in a decoupled manner.  It enables the implementation of event-driven architectures  and facilitates communication between different components  of an application.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Signal Definition: Define custom signals using a  simple and intuitive syntax.</li> <li>Signal Broadcasting: Broadcast signals to multiple  listeners without direct dependencies.</li> <li>Signal Subscription: Register listeners to receive  signals of interest.</li> <li>Flexible Dispatching: Control the behavior of signal  dispatching, including synchronous or asynchronous processing.</li> <li>Thread-Safe: Safely broadcast signals in multithreaded  or multiprocessing environments.</li> <li>Extensible: Easily integrate the library with  existing codebases and frameworks.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install the Signal using favorite package manager, for example with pip:</p> <pre><code>pip install signal\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#signal-definition","title":"Signal Definition","text":"<p>To define a signal, import the <code>Signal</code> class from the library  and create an instance:</p> <pre><code>from signal import Signal\nsignal = Signal()\n</code></pre> <p>alternatively, you can use the <code>a named signal</code>:</p> <pre><code>signal = Signal('my_signal')\n</code></pre> <p>Trying to instantiate a signal with the same name will return the same signal instance:</p> <pre><code>signal1 = Signal('my_signal')\nsignal2 = Signal('my_signal')\nassert signal1 is signal2\n</code></pre>"},{"location":"#signal-broadcasting","title":"Signal Broadcasting","text":"<p>To broadcast a signal, call the <code>fire</code> method of the signal with relevant data:</p> <pre><code>from signal import Signal\nsignal = Signal()\nsignal.fire()(data='Hello World!')\n</code></pre> <p>The <code>fire</code> method returns a callable that take parameters to be passed to the listeners. The parameters can be  positional or named.</p> <p><code>fire</code> method can be called with or without parameters:</p> <pre><code>signal.fire(events=[\"my_event\"])()\n</code></pre>"},{"location":"#signal-subscription","title":"Signal Subscription","text":"<p>To subscribe to a signal, use the <code>register</code> method of the signal:</p> <pre><code>from signal import Signal\nsignal = Signal()\ndef listener(data):\nprint(data)\nsignal.register(listener)\nsignal.fire()(data='Hello World!')\n</code></pre> <p>or using the function decorator:</p> <pre><code>@signal.wire.fn\ndef listener(data):\nprint(data)\n</code></pre> <p>A notable feature of this library, is that you can decorate a class and class methods as callbacks. So, all the instances of the decorated class will have the decorated methods registered as callbacks:</p> <pre><code>from signal import Signal\nsignal = Signal()\n@signal.wire.cls\nclass MyClass:\ndef __init__(self, name):\nself.name = name\n@signal.wire.cls_cb\ndef listener(self, data):\nprint(f'{self.name}: {data}')\ninstance1 = MyClass('instance1')\ninstance2 = MyClass('instance2')\nsignal.fire()(data='Hello World!')\n# prints:\n# instance1: Hello World!\n# instance2: Hello World!\n</code></pre> <p>Sometimes you want that a signal handle several signals, like channels in a message broker. To do that, you can write:</p> <pre><code>from signal import Signal\nsignal = Signal()\n@signal.wire.cls\nclass MyClass:\ndef __init__(self, name):\nself.name = name\n@signal.wire.on_event('my_event')\ndef listener_a(self, data):\nprint(f'{self.name}: {data}')\n@signal.wire.on_event('my_event_2')\ndef listener_b(self, data):\nprint(f'{self.name}: {data}')\ninstance1 = MyClass('instance1')\nsignal.fire(events=['my_event'])(data='Hello World!')\n# calls listener_a\n</code></pre> <p>You can also specify a receiver for a signal, with the code above:</p> <pre><code>instance1 = MyClass('instance1')\ninstance2 = MyClass('instance2')\nsignal.fire(events=['my_event'], receiver=[instance1])(data='Hello World!')\n# only instance1 receives the signal\n</code></pre> <p>You can also specify dependencies between events of the same signal, with the code above. You can specify if you want to use the result of the previous event as a parameter of the next event:</p> <pre><code>from signal import Signal\nsignal = Signal()\n@signal.wire.fn(event=\"fn_event\", depends_on={\"my_cls_event\"})\ndef on_processing_data():\nprint(\"processing data ended !\")\n@signal.wire.cls\nclass MyClass:\ndef __init__(self, name):\nself.name = name\n@signal.wire.on_event('my_cls_event')\ndef listener(self):\nprint(f'{self.name}: Hello World!')\ninstance = MyClass('instance1')\nsignal.fire(events=['fn_event'])()\n# because fn_event depends on my_cls_event, my_cls_event is called first\n# automatically\n</code></pre> <p>You can also get all path of dependencies between events of the same signal:</p> <pre><code># options to get the longest path too\nevents_to_fire_in_order = signal.get_event_path(\"fn_event\", path_type=PathType.SHORTEST)\nprint(events_to_fire_in_order)\n# prints:\n#[['my_cls_event', 'fn_event']]\n</code></pre>"},{"location":"#asynchronous-signal-processing","title":"Asynchronous Signal Processing","text":"<p>By default, signals are processed synchronously. However, you can specify that a signal should be processed in an asynchronous manner. All synchronous listeners will be run in a separate thread.</p> <pre><code>signal = Signal()\n...\nawait signal.fire_async()(data='Hello World!')\n</code></pre>"},{"location":"#contribution","title":"Contribution","text":"<p>Contributions are welcome! If you find any issues or have suggestions for improvement, please open an issue or submit a pull request on the GitHub repository.</p>"},{"location":"#license","title":"License","text":"<p><code>MIT</code></p>"}]}